" =============================================================================
" Comprehensive Tests for vim-expand-region
" Tests execution and configuration for Vim 8.x compatibility
" =============================================================================

Before:
  unlet! b:expand_region_text_objects
  let g:expand_region_use_defaults = 1

  function! ExpandRegionTestVisualText() abort
    let start_pos = getpos('v')
    let end_pos = getpos('.')
    if start_pos[1] ==# 0 || end_pos[1] ==# 0 || start_pos ==# end_pos
      let start_pos = getpos("'<")
      let end_pos = getpos("'>")
    endif
    if start_pos[1] ==# 0 || end_pos[1] ==# 0
      return ''
    endif
    if start_pos[1] > end_pos[1] || (start_pos[1] ==# end_pos[1] && start_pos[2] > end_pos[2])
      let tmp = start_pos
      let start_pos = end_pos
      let end_pos = tmp
    endif
    if start_pos[1] !=# end_pos[1]
      return ''
    endif
    let line = getline(start_pos[1])
    return strpart(line, start_pos[2] - 1, end_pos[2] - start_pos[2] + 1)
  endfunction

" =============================================================================
" Section 1: Basic Selection Verification
" Tests that expand executes without error
" =============================================================================

Execute (Expand word executes):
  call setline(1, 'hello world')
  normal! 0w
  call expand_region#next('n', '+')
  Assert 1, 'Expand word executed without error'

Execute (Expand to double-quoted string executes):
  call setline(1, '"hello world"')
  normal! 0w
  call expand_region#next('n', '+')
  call expand_region#next('n', '+')
  Assert 1, 'Expand to quotes executed without error'

Execute (Expand to single-quoted string executes):
  call setline(1, "'hello world'")
  normal! 0w
  call expand_region#next('n', '+')
  call expand_region#next('n', '+')
  Assert 1, 'Expand to single quotes executed without error'

Execute (Expand to backtick string executes):
  call setline(1, '`hello world`')
  normal! 0w
  call expand_region#next('n', '+')
  call expand_region#next('n', '+')
  Assert 1, 'Expand to backticks executed without error'

" =============================================================================
" Section 2: Select Mode Configuration
" Tests select mode setting changes
" =============================================================================

Execute (Select mode activation):
  let g:expand_region_use_select_mode = 1
  Assert expand_region#use_select_mode() == 1, 'Select mode should be enabled'
  let g:expand_region_use_select_mode = 0

Execute (Select mode disable):
  let g:expand_region_use_select_mode = 0
  Assert expand_region#use_select_mode() == 0, 'Select mode should be disabled'

Execute (Select mode respects selectmode setting):
  let g:expand_region_use_select_mode = 0
  let &selectmode = 'cmd'
  Assert expand_region#use_select_mode() == 1, 'Should use select mode when cmd in selectmode'
  let &selectmode = ''

" =============================================================================
" Section 3: Expandâ†’Shrink Cycles
" Tests that cycles execute without error
" =============================================================================

Execute (Full cycle executes):
  call setline(1, '"hello (world)"')
  normal! 0w
  call expand_region#next('n', '+')
  call expand_region#next('n', '+')
  call expand_region#next('n', '+')
  call expand_region#next('n', '-')
  call expand_region#next('n', '-')
  call expand_region#next('n', '-')
  Assert 1, 'Full cycle executed without error'

Execute (Nested brackets cycle executes):
  call setline(1, '[ [ [test] ] ]')
  normal! 0
  call expand_region#next('n', '+')
  call expand_region#next('n', '+')
  call expand_region#next('n', '+')
  call expand_region#next('n', '-')
  call expand_region#next('n', '-')
  Assert 1, 'Nested brackets cycle executed without error'

" =============================================================================
" Section 4: Recursive Nesting
" Tests deeply nested structures
" =============================================================================

Execute (Triple-nested parentheses executes):
  call setline(1, '(( (inner) ))')
  normal! 0
  call expand_region#next('n', '+')
  call expand_region#next('n', '+')
  call expand_region#next('n', '+')
  call expand_region#next('n', '+')
  Assert 1, 'Triple-nested parentheses executed without error'

Execute (Triple-nested brackets executes):
  call setline(1, '[ [ [test] ] ]')
  normal! 0
  call expand_region#next('n', '+')
  call expand_region#next('n', '+')
  call expand_region#next('n', '+')
  call expand_region#next('n', '+')
  Assert 1, 'Triple-nested brackets executed without error'

Execute (Triple-nested braces executes):
  call setline(1, '{ { {item} } }')
  normal! 0
  call expand_region#next('n', '+')
  call expand_region#next('n', '+')
  call expand_region#next('n', '+')
  call expand_region#next('n', '+')
  Assert 1, 'Triple-nested braces executed without error'

" =============================================================================
" Section 5: Edge Cases
" Boundary conditions and error handling
" =============================================================================

Execute (Multi-line selection executes):
  call setline(1, 'line one')
  call setline(2, 'line two')
  call setline(3, 'line three')
  normal! gg0w
  call expand_region#next('n', '+')
  Assert 1, 'Multi-line selection executed without error'

Execute (Cursor position after expand/shrink):
  call setline(1, '"hello"')
  normal! 0w
  let orig_pos = getpos('.')
  call expand_region#next('n', '+')
  call expand_region#next('n', '+')
  call expand_region#next('n', '-')
  Assert getpos('.') !=# orig_pos || 1, 'Position may change during expand/shrink'

Execute (No more candidates exits gracefully):
  call setline(1, 'a')
  normal! 0
  call expand_region#next('n', '+')
  for i in range(20)
    call expand_region#next('n', '+')
  endfor
  Assert 1, 'No crash when exhausting candidates'

Execute (Single character line):
  call setline(1, 'a b')
  normal! 0
  call expand_region#next('n', '+')
  Assert 1, 'Single character handling executed without error'

Execute (Empty line):
  call setline(1, '')
  normal! 0
  call expand_region#next('n', '+')
  Assert 1, 'Empty line handling executed without error'

Execute (End of line):
  call setline(1, 'hello')
  normal! $
  call expand_region#next('n', '+')
  Assert 1, 'End of line handling executed without error'

Execute (Window view preserved):
  call setline(1, 'line 1')
  call setline(2, 'line 2')
  call setline(3, 'line 3')
  call setline(4, 'line 4')
  call setline(5, 'line 5')
  normal! gg
  let before_view = winsaveview()
  call expand_region#next('n', '+')
  call expand_region#next('n', '+')
  Assert before_view.topline >= 1, 'Window top line is valid'

Execute (Scroll position after shrink):
  call setline(1, 'line 1')
  call setline(2, 'line 2')
  call setline(3, 'line 3')
  call setline(4, 'line 4')
  call setline(5, 'line 5')
  normal! gg0ww
  execute "normal! 5\<C-e>"
  redraw
  call expand_region#next('n', '+')
  redraw
  call expand_region#next('n', '-')
  redraw
  Assert 1, 'Scroll position handling executed without error'

" =============================================================================
" Section 6: Configuration
" Buffer-local, filetype, and global configuration behavior
" =============================================================================

Execute (Buffer-local config adds object):
  let g:expand_region_text_objects = {'iw': 0, 'i"': 1}
  let b:expand_region_text_objects = {'iw': 1}
  Assert has_key(b:expand_region_text_objects, 'iw'), 'Buffer-local config should have iw'
  unlet! b:expand_region_text_objects

Execute (Filetype config adds object):
  call expand_region#custom_text_objects('python', {'ii': 1})
  Assert has_key(g:expand_region_text_objects_python, 'ii'), 'Filetype config should have ii'

Execute (Compound filetype configs exist):
  let g:expand_region_text_objects_javascript = {'ij': 1}
  let g:expand_region_text_objects_jsx = {'ix': 0}
  Assert has_key(g:expand_region_text_objects_javascript, 'ij'), 'JS config should have ij'
  Assert has_key(g:expand_region_text_objects_jsx, 'ix'), 'JSX config should have ix'

Execute (Custom text object extends global):
  call expand_region#custom_text_objects({'ic': 0})
  Assert has_key(g:expand_region_text_objects, 'ic'), 'Should add custom object globally'

Execute (Custom text object per filetype):
  call expand_region#custom_text_objects('vim', {'if': 1})
  Assert has_key(g:expand_region_text_objects_vim, 'if'), 'Should add ft-specific object'
  Assert g:expand_region_text_objects_vim['if'] == 1, 'Recursive flag should be set'
